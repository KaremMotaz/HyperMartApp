// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'categories_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$CategoriesState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CategoriesState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState()';
}


}

/// @nodoc
class $CategoriesStateCopyWith<$Res>  {
$CategoriesStateCopyWith(CategoriesState _, $Res Function(CategoriesState) __);
}


/// Adds pattern-matching-related methods to [CategoriesState].
extension CategoriesStatePatterns on CategoriesState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _CategoriesInitial value)?  categoriesInitial,TResult Function( CategoriesLoading value)?  categoriesLoading,TResult Function( DeleteCategoriesLoading value)?  categoriesDeleteLoading,TResult Function( UpdateCategoryLoading value)?  categoriesUpdateLoading,TResult Function( GetCategoryByIdLoading value)?  categoriesGetByIdLoading,TResult Function( AddCategoryLoading value)?  categoriesAddLoading,TResult Function( GetCategoriesSuccess value)?  categoriesGetSuccess,TResult Function( GetCategoryByIdSuccessState value)?  categoriesGetByIdSuccess,TResult Function( UpdateCategorySuccess value)?  categoriesUpdateSuccess,TResult Function( AddCategorySuccess value)?  categoriesAddSuccess,TResult Function( DeleteCategorySuccess value)?  categoriesDeleteSuccess,TResult Function( CategoriesFailure value)?  categoriesFailure,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _CategoriesInitial() when categoriesInitial != null:
return categoriesInitial(_that);case CategoriesLoading() when categoriesLoading != null:
return categoriesLoading(_that);case DeleteCategoriesLoading() when categoriesDeleteLoading != null:
return categoriesDeleteLoading(_that);case UpdateCategoryLoading() when categoriesUpdateLoading != null:
return categoriesUpdateLoading(_that);case GetCategoryByIdLoading() when categoriesGetByIdLoading != null:
return categoriesGetByIdLoading(_that);case AddCategoryLoading() when categoriesAddLoading != null:
return categoriesAddLoading(_that);case GetCategoriesSuccess() when categoriesGetSuccess != null:
return categoriesGetSuccess(_that);case GetCategoryByIdSuccessState() when categoriesGetByIdSuccess != null:
return categoriesGetByIdSuccess(_that);case UpdateCategorySuccess() when categoriesUpdateSuccess != null:
return categoriesUpdateSuccess(_that);case AddCategorySuccess() when categoriesAddSuccess != null:
return categoriesAddSuccess(_that);case DeleteCategorySuccess() when categoriesDeleteSuccess != null:
return categoriesDeleteSuccess(_that);case CategoriesFailure() when categoriesFailure != null:
return categoriesFailure(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _CategoriesInitial value)  categoriesInitial,required TResult Function( CategoriesLoading value)  categoriesLoading,required TResult Function( DeleteCategoriesLoading value)  categoriesDeleteLoading,required TResult Function( UpdateCategoryLoading value)  categoriesUpdateLoading,required TResult Function( GetCategoryByIdLoading value)  categoriesGetByIdLoading,required TResult Function( AddCategoryLoading value)  categoriesAddLoading,required TResult Function( GetCategoriesSuccess value)  categoriesGetSuccess,required TResult Function( GetCategoryByIdSuccessState value)  categoriesGetByIdSuccess,required TResult Function( UpdateCategorySuccess value)  categoriesUpdateSuccess,required TResult Function( AddCategorySuccess value)  categoriesAddSuccess,required TResult Function( DeleteCategorySuccess value)  categoriesDeleteSuccess,required TResult Function( CategoriesFailure value)  categoriesFailure,}){
final _that = this;
switch (_that) {
case _CategoriesInitial():
return categoriesInitial(_that);case CategoriesLoading():
return categoriesLoading(_that);case DeleteCategoriesLoading():
return categoriesDeleteLoading(_that);case UpdateCategoryLoading():
return categoriesUpdateLoading(_that);case GetCategoryByIdLoading():
return categoriesGetByIdLoading(_that);case AddCategoryLoading():
return categoriesAddLoading(_that);case GetCategoriesSuccess():
return categoriesGetSuccess(_that);case GetCategoryByIdSuccessState():
return categoriesGetByIdSuccess(_that);case UpdateCategorySuccess():
return categoriesUpdateSuccess(_that);case AddCategorySuccess():
return categoriesAddSuccess(_that);case DeleteCategorySuccess():
return categoriesDeleteSuccess(_that);case CategoriesFailure():
return categoriesFailure(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _CategoriesInitial value)?  categoriesInitial,TResult? Function( CategoriesLoading value)?  categoriesLoading,TResult? Function( DeleteCategoriesLoading value)?  categoriesDeleteLoading,TResult? Function( UpdateCategoryLoading value)?  categoriesUpdateLoading,TResult? Function( GetCategoryByIdLoading value)?  categoriesGetByIdLoading,TResult? Function( AddCategoryLoading value)?  categoriesAddLoading,TResult? Function( GetCategoriesSuccess value)?  categoriesGetSuccess,TResult? Function( GetCategoryByIdSuccessState value)?  categoriesGetByIdSuccess,TResult? Function( UpdateCategorySuccess value)?  categoriesUpdateSuccess,TResult? Function( AddCategorySuccess value)?  categoriesAddSuccess,TResult? Function( DeleteCategorySuccess value)?  categoriesDeleteSuccess,TResult? Function( CategoriesFailure value)?  categoriesFailure,}){
final _that = this;
switch (_that) {
case _CategoriesInitial() when categoriesInitial != null:
return categoriesInitial(_that);case CategoriesLoading() when categoriesLoading != null:
return categoriesLoading(_that);case DeleteCategoriesLoading() when categoriesDeleteLoading != null:
return categoriesDeleteLoading(_that);case UpdateCategoryLoading() when categoriesUpdateLoading != null:
return categoriesUpdateLoading(_that);case GetCategoryByIdLoading() when categoriesGetByIdLoading != null:
return categoriesGetByIdLoading(_that);case AddCategoryLoading() when categoriesAddLoading != null:
return categoriesAddLoading(_that);case GetCategoriesSuccess() when categoriesGetSuccess != null:
return categoriesGetSuccess(_that);case GetCategoryByIdSuccessState() when categoriesGetByIdSuccess != null:
return categoriesGetByIdSuccess(_that);case UpdateCategorySuccess() when categoriesUpdateSuccess != null:
return categoriesUpdateSuccess(_that);case AddCategorySuccess() when categoriesAddSuccess != null:
return categoriesAddSuccess(_that);case DeleteCategorySuccess() when categoriesDeleteSuccess != null:
return categoriesDeleteSuccess(_that);case CategoriesFailure() when categoriesFailure != null:
return categoriesFailure(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  categoriesInitial,TResult Function()?  categoriesLoading,TResult Function()?  categoriesDeleteLoading,TResult Function()?  categoriesUpdateLoading,TResult Function()?  categoriesGetByIdLoading,TResult Function()?  categoriesAddLoading,TResult Function( GetCategoriesResponse categoriesResponse)?  categoriesGetSuccess,TResult Function( GetCategoryByIdResponse getCategoryByIdModel)?  categoriesGetByIdSuccess,TResult Function( UpdateCategoryResponse updateCategoryResponse)?  categoriesUpdateSuccess,TResult Function( AddCategoryResponse addCategoryResponse)?  categoriesAddSuccess,TResult Function()?  categoriesDeleteSuccess,TResult Function( ApiErrorModel apiErrorModel)?  categoriesFailure,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _CategoriesInitial() when categoriesInitial != null:
return categoriesInitial();case CategoriesLoading() when categoriesLoading != null:
return categoriesLoading();case DeleteCategoriesLoading() when categoriesDeleteLoading != null:
return categoriesDeleteLoading();case UpdateCategoryLoading() when categoriesUpdateLoading != null:
return categoriesUpdateLoading();case GetCategoryByIdLoading() when categoriesGetByIdLoading != null:
return categoriesGetByIdLoading();case AddCategoryLoading() when categoriesAddLoading != null:
return categoriesAddLoading();case GetCategoriesSuccess() when categoriesGetSuccess != null:
return categoriesGetSuccess(_that.categoriesResponse);case GetCategoryByIdSuccessState() when categoriesGetByIdSuccess != null:
return categoriesGetByIdSuccess(_that.getCategoryByIdModel);case UpdateCategorySuccess() when categoriesUpdateSuccess != null:
return categoriesUpdateSuccess(_that.updateCategoryResponse);case AddCategorySuccess() when categoriesAddSuccess != null:
return categoriesAddSuccess(_that.addCategoryResponse);case DeleteCategorySuccess() when categoriesDeleteSuccess != null:
return categoriesDeleteSuccess();case CategoriesFailure() when categoriesFailure != null:
return categoriesFailure(_that.apiErrorModel);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  categoriesInitial,required TResult Function()  categoriesLoading,required TResult Function()  categoriesDeleteLoading,required TResult Function()  categoriesUpdateLoading,required TResult Function()  categoriesGetByIdLoading,required TResult Function()  categoriesAddLoading,required TResult Function( GetCategoriesResponse categoriesResponse)  categoriesGetSuccess,required TResult Function( GetCategoryByIdResponse getCategoryByIdModel)  categoriesGetByIdSuccess,required TResult Function( UpdateCategoryResponse updateCategoryResponse)  categoriesUpdateSuccess,required TResult Function( AddCategoryResponse addCategoryResponse)  categoriesAddSuccess,required TResult Function()  categoriesDeleteSuccess,required TResult Function( ApiErrorModel apiErrorModel)  categoriesFailure,}) {final _that = this;
switch (_that) {
case _CategoriesInitial():
return categoriesInitial();case CategoriesLoading():
return categoriesLoading();case DeleteCategoriesLoading():
return categoriesDeleteLoading();case UpdateCategoryLoading():
return categoriesUpdateLoading();case GetCategoryByIdLoading():
return categoriesGetByIdLoading();case AddCategoryLoading():
return categoriesAddLoading();case GetCategoriesSuccess():
return categoriesGetSuccess(_that.categoriesResponse);case GetCategoryByIdSuccessState():
return categoriesGetByIdSuccess(_that.getCategoryByIdModel);case UpdateCategorySuccess():
return categoriesUpdateSuccess(_that.updateCategoryResponse);case AddCategorySuccess():
return categoriesAddSuccess(_that.addCategoryResponse);case DeleteCategorySuccess():
return categoriesDeleteSuccess();case CategoriesFailure():
return categoriesFailure(_that.apiErrorModel);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  categoriesInitial,TResult? Function()?  categoriesLoading,TResult? Function()?  categoriesDeleteLoading,TResult? Function()?  categoriesUpdateLoading,TResult? Function()?  categoriesGetByIdLoading,TResult? Function()?  categoriesAddLoading,TResult? Function( GetCategoriesResponse categoriesResponse)?  categoriesGetSuccess,TResult? Function( GetCategoryByIdResponse getCategoryByIdModel)?  categoriesGetByIdSuccess,TResult? Function( UpdateCategoryResponse updateCategoryResponse)?  categoriesUpdateSuccess,TResult? Function( AddCategoryResponse addCategoryResponse)?  categoriesAddSuccess,TResult? Function()?  categoriesDeleteSuccess,TResult? Function( ApiErrorModel apiErrorModel)?  categoriesFailure,}) {final _that = this;
switch (_that) {
case _CategoriesInitial() when categoriesInitial != null:
return categoriesInitial();case CategoriesLoading() when categoriesLoading != null:
return categoriesLoading();case DeleteCategoriesLoading() when categoriesDeleteLoading != null:
return categoriesDeleteLoading();case UpdateCategoryLoading() when categoriesUpdateLoading != null:
return categoriesUpdateLoading();case GetCategoryByIdLoading() when categoriesGetByIdLoading != null:
return categoriesGetByIdLoading();case AddCategoryLoading() when categoriesAddLoading != null:
return categoriesAddLoading();case GetCategoriesSuccess() when categoriesGetSuccess != null:
return categoriesGetSuccess(_that.categoriesResponse);case GetCategoryByIdSuccessState() when categoriesGetByIdSuccess != null:
return categoriesGetByIdSuccess(_that.getCategoryByIdModel);case UpdateCategorySuccess() when categoriesUpdateSuccess != null:
return categoriesUpdateSuccess(_that.updateCategoryResponse);case AddCategorySuccess() when categoriesAddSuccess != null:
return categoriesAddSuccess(_that.addCategoryResponse);case DeleteCategorySuccess() when categoriesDeleteSuccess != null:
return categoriesDeleteSuccess();case CategoriesFailure() when categoriesFailure != null:
return categoriesFailure(_that.apiErrorModel);case _:
  return null;

}
}

}

/// @nodoc


class _CategoriesInitial implements CategoriesState {
  const _CategoriesInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CategoriesInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesInitial()';
}


}




/// @nodoc


class CategoriesLoading implements CategoriesState {
  const CategoriesLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CategoriesLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesLoading()';
}


}




/// @nodoc


class DeleteCategoriesLoading implements CategoriesState {
  const DeleteCategoriesLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteCategoriesLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesDeleteLoading()';
}


}




/// @nodoc


class UpdateCategoryLoading implements CategoriesState {
  const UpdateCategoryLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateCategoryLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesUpdateLoading()';
}


}




/// @nodoc


class GetCategoryByIdLoading implements CategoriesState {
  const GetCategoryByIdLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is GetCategoryByIdLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesGetByIdLoading()';
}


}




/// @nodoc


class AddCategoryLoading implements CategoriesState {
  const AddCategoryLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AddCategoryLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesAddLoading()';
}


}




/// @nodoc


class GetCategoriesSuccess implements CategoriesState {
  const GetCategoriesSuccess({required this.categoriesResponse});
  

 final  GetCategoriesResponse categoriesResponse;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$GetCategoriesSuccessCopyWith<GetCategoriesSuccess> get copyWith => _$GetCategoriesSuccessCopyWithImpl<GetCategoriesSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is GetCategoriesSuccess&&(identical(other.categoriesResponse, categoriesResponse) || other.categoriesResponse == categoriesResponse));
}


@override
int get hashCode => Object.hash(runtimeType,categoriesResponse);

@override
String toString() {
  return 'CategoriesState.categoriesGetSuccess(categoriesResponse: $categoriesResponse)';
}


}

/// @nodoc
abstract mixin class $GetCategoriesSuccessCopyWith<$Res> implements $CategoriesStateCopyWith<$Res> {
  factory $GetCategoriesSuccessCopyWith(GetCategoriesSuccess value, $Res Function(GetCategoriesSuccess) _then) = _$GetCategoriesSuccessCopyWithImpl;
@useResult
$Res call({
 GetCategoriesResponse categoriesResponse
});




}
/// @nodoc
class _$GetCategoriesSuccessCopyWithImpl<$Res>
    implements $GetCategoriesSuccessCopyWith<$Res> {
  _$GetCategoriesSuccessCopyWithImpl(this._self, this._then);

  final GetCategoriesSuccess _self;
  final $Res Function(GetCategoriesSuccess) _then;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? categoriesResponse = null,}) {
  return _then(GetCategoriesSuccess(
categoriesResponse: null == categoriesResponse ? _self.categoriesResponse : categoriesResponse // ignore: cast_nullable_to_non_nullable
as GetCategoriesResponse,
  ));
}


}

/// @nodoc


class GetCategoryByIdSuccessState implements CategoriesState {
  const GetCategoryByIdSuccessState({required this.getCategoryByIdModel});
  

 final  GetCategoryByIdResponse getCategoryByIdModel;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$GetCategoryByIdSuccessStateCopyWith<GetCategoryByIdSuccessState> get copyWith => _$GetCategoryByIdSuccessStateCopyWithImpl<GetCategoryByIdSuccessState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is GetCategoryByIdSuccessState&&(identical(other.getCategoryByIdModel, getCategoryByIdModel) || other.getCategoryByIdModel == getCategoryByIdModel));
}


@override
int get hashCode => Object.hash(runtimeType,getCategoryByIdModel);

@override
String toString() {
  return 'CategoriesState.categoriesGetByIdSuccess(getCategoryByIdModel: $getCategoryByIdModel)';
}


}

/// @nodoc
abstract mixin class $GetCategoryByIdSuccessStateCopyWith<$Res> implements $CategoriesStateCopyWith<$Res> {
  factory $GetCategoryByIdSuccessStateCopyWith(GetCategoryByIdSuccessState value, $Res Function(GetCategoryByIdSuccessState) _then) = _$GetCategoryByIdSuccessStateCopyWithImpl;
@useResult
$Res call({
 GetCategoryByIdResponse getCategoryByIdModel
});




}
/// @nodoc
class _$GetCategoryByIdSuccessStateCopyWithImpl<$Res>
    implements $GetCategoryByIdSuccessStateCopyWith<$Res> {
  _$GetCategoryByIdSuccessStateCopyWithImpl(this._self, this._then);

  final GetCategoryByIdSuccessState _self;
  final $Res Function(GetCategoryByIdSuccessState) _then;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? getCategoryByIdModel = null,}) {
  return _then(GetCategoryByIdSuccessState(
getCategoryByIdModel: null == getCategoryByIdModel ? _self.getCategoryByIdModel : getCategoryByIdModel // ignore: cast_nullable_to_non_nullable
as GetCategoryByIdResponse,
  ));
}


}

/// @nodoc


class UpdateCategorySuccess implements CategoriesState {
  const UpdateCategorySuccess({required this.updateCategoryResponse});
  

 final  UpdateCategoryResponse updateCategoryResponse;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateCategorySuccessCopyWith<UpdateCategorySuccess> get copyWith => _$UpdateCategorySuccessCopyWithImpl<UpdateCategorySuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateCategorySuccess&&(identical(other.updateCategoryResponse, updateCategoryResponse) || other.updateCategoryResponse == updateCategoryResponse));
}


@override
int get hashCode => Object.hash(runtimeType,updateCategoryResponse);

@override
String toString() {
  return 'CategoriesState.categoriesUpdateSuccess(updateCategoryResponse: $updateCategoryResponse)';
}


}

/// @nodoc
abstract mixin class $UpdateCategorySuccessCopyWith<$Res> implements $CategoriesStateCopyWith<$Res> {
  factory $UpdateCategorySuccessCopyWith(UpdateCategorySuccess value, $Res Function(UpdateCategorySuccess) _then) = _$UpdateCategorySuccessCopyWithImpl;
@useResult
$Res call({
 UpdateCategoryResponse updateCategoryResponse
});




}
/// @nodoc
class _$UpdateCategorySuccessCopyWithImpl<$Res>
    implements $UpdateCategorySuccessCopyWith<$Res> {
  _$UpdateCategorySuccessCopyWithImpl(this._self, this._then);

  final UpdateCategorySuccess _self;
  final $Res Function(UpdateCategorySuccess) _then;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? updateCategoryResponse = null,}) {
  return _then(UpdateCategorySuccess(
updateCategoryResponse: null == updateCategoryResponse ? _self.updateCategoryResponse : updateCategoryResponse // ignore: cast_nullable_to_non_nullable
as UpdateCategoryResponse,
  ));
}


}

/// @nodoc


class AddCategorySuccess implements CategoriesState {
  const AddCategorySuccess({required this.addCategoryResponse});
  

 final  AddCategoryResponse addCategoryResponse;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AddCategorySuccessCopyWith<AddCategorySuccess> get copyWith => _$AddCategorySuccessCopyWithImpl<AddCategorySuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AddCategorySuccess&&(identical(other.addCategoryResponse, addCategoryResponse) || other.addCategoryResponse == addCategoryResponse));
}


@override
int get hashCode => Object.hash(runtimeType,addCategoryResponse);

@override
String toString() {
  return 'CategoriesState.categoriesAddSuccess(addCategoryResponse: $addCategoryResponse)';
}


}

/// @nodoc
abstract mixin class $AddCategorySuccessCopyWith<$Res> implements $CategoriesStateCopyWith<$Res> {
  factory $AddCategorySuccessCopyWith(AddCategorySuccess value, $Res Function(AddCategorySuccess) _then) = _$AddCategorySuccessCopyWithImpl;
@useResult
$Res call({
 AddCategoryResponse addCategoryResponse
});




}
/// @nodoc
class _$AddCategorySuccessCopyWithImpl<$Res>
    implements $AddCategorySuccessCopyWith<$Res> {
  _$AddCategorySuccessCopyWithImpl(this._self, this._then);

  final AddCategorySuccess _self;
  final $Res Function(AddCategorySuccess) _then;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? addCategoryResponse = null,}) {
  return _then(AddCategorySuccess(
addCategoryResponse: null == addCategoryResponse ? _self.addCategoryResponse : addCategoryResponse // ignore: cast_nullable_to_non_nullable
as AddCategoryResponse,
  ));
}


}

/// @nodoc


class DeleteCategorySuccess implements CategoriesState {
  const DeleteCategorySuccess();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteCategorySuccess);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CategoriesState.categoriesDeleteSuccess()';
}


}




/// @nodoc


class CategoriesFailure implements CategoriesState {
  const CategoriesFailure({required this.apiErrorModel});
  

 final  ApiErrorModel apiErrorModel;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CategoriesFailureCopyWith<CategoriesFailure> get copyWith => _$CategoriesFailureCopyWithImpl<CategoriesFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CategoriesFailure&&(identical(other.apiErrorModel, apiErrorModel) || other.apiErrorModel == apiErrorModel));
}


@override
int get hashCode => Object.hash(runtimeType,apiErrorModel);

@override
String toString() {
  return 'CategoriesState.categoriesFailure(apiErrorModel: $apiErrorModel)';
}


}

/// @nodoc
abstract mixin class $CategoriesFailureCopyWith<$Res> implements $CategoriesStateCopyWith<$Res> {
  factory $CategoriesFailureCopyWith(CategoriesFailure value, $Res Function(CategoriesFailure) _then) = _$CategoriesFailureCopyWithImpl;
@useResult
$Res call({
 ApiErrorModel apiErrorModel
});




}
/// @nodoc
class _$CategoriesFailureCopyWithImpl<$Res>
    implements $CategoriesFailureCopyWith<$Res> {
  _$CategoriesFailureCopyWithImpl(this._self, this._then);

  final CategoriesFailure _self;
  final $Res Function(CategoriesFailure) _then;

/// Create a copy of CategoriesState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? apiErrorModel = null,}) {
  return _then(CategoriesFailure(
apiErrorModel: null == apiErrorModel ? _self.apiErrorModel : apiErrorModel // ignore: cast_nullable_to_non_nullable
as ApiErrorModel,
  ));
}


}

// dart format on
